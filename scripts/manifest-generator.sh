#!/usr/bin/env bash

# Manifest Generator for Atmos Infrastructure
#
# Generates infrastructure manifests, templates, and resource definitions
# for terminal-first workflows
#
# Usage:
#   ./scripts/manifest-generator.sh stack fnx-dev-testenv-01      # Generate stack manifest
#   ./scripts/manifest-generator.sh component vpc                # Generate component manifest  
#   ./scripts/manifest-generator.sh template new-stack           # Generate new stack template
#   ./scripts/manifest-generator.sh resource s3-bucket          # Generate resource template

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

print_usage() {
    echo -e "${CYAN}🛠️  Manifest Generator Usage${NC}"
    echo -e "${YELLOW}────────────────────────────────────────────────────────${NC}"
    echo ""
    echo -e "${WHITE}Commands:${NC}"
    echo -e "  ${GREEN}stack <stack-name>${NC}          Generate complete stack manifest"
    echo -e "  ${GREEN}component <component>${NC}       Generate component manifest"
    echo -e "  ${GREEN}template <type> <name>${NC}      Generate template (stack, component, environment)"
    echo -e "  ${GREEN}resource <resource-type>${NC}    Generate Terraform resource template"
    echo -e "  ${GREEN}list${NC}                      List available templates"
    echo ""
    echo -e "${WHITE}Examples:${NC}"
    echo -e "  ${GREEN}./scripts/manifest-generator.sh stack fnx-dev-testenv-01${NC}"
    echo -e "  ${GREEN}./scripts/manifest-generator.sh component vpc${NC}"
    echo -e "  ${GREEN}./scripts/manifest-generator.sh template stack my-new-stack${NC}"
    echo -e "  ${GREEN}./scripts/manifest-generator.sh resource aws_s3_bucket${NC}"
}

generate_stack_manifest() {
    local stack="$1"
    local output_file="${2:-manifests/${stack}-manifest.yaml}"
    
    echo -e "${CYAN}📋 Generating manifest for stack: ${stack}${NC}"
    
    # Create output directory
    mkdir -p "$(dirname "$output_file")"
    
    # Generate manifest using Atmos
    if atmos describe stacks -s "$stack" --format yaml > "$output_file" 2>/dev/null; then
        echo -e "${GREEN}✅ Stack manifest generated: ${output_file}${NC}"
        
        # Add metadata
        cat << EOF >> "$output_file"

# Generated by Gaia Manifest Generator
# Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
# Stack: $stack
# Generator: manifest-generator.sh
EOF
        
        # Show summary
        local components=$(grep -c "components:" "$output_file" || echo "0")
        echo -e "${BLUE}📊 Manifest Summary:${NC}"
        echo -e "  Stack: ${YELLOW}$stack${NC}"
        echo -e "  File: ${YELLOW}$output_file${NC}"
        echo -e "  Size: ${YELLOW}$(wc -l < "$output_file") lines${NC}"
        
    else
        echo -e "${RED}❌ Failed to generate manifest for stack: $stack${NC}"
        return 1
    fi
}

generate_component_manifest() {
    local component="$1"
    local stack="${2:-fnx-dev-testenv-01}"
    local output_file="${3:-manifests/components/${component}-manifest.yaml}"
    
    echo -e "${CYAN}📦 Generating manifest for component: ${component}${NC}"
    
    mkdir -p "$(dirname "$output_file")"
    
    # Generate component-specific manifest
    cat << EOF > "$output_file"
# Component Manifest: $component
# Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
# Stack Context: $stack

component: $component
type: terraform
source: components/terraform/$component

configuration:
EOF
    
    # Try to extract configuration from Atmos
    if atmos describe component "$component" -s "$stack" --format yaml >> "$output_file" 2>/dev/null; then
        echo -e "${GREEN}✅ Component manifest generated: ${output_file}${NC}"
    else
        # Generate basic manifest
        cat << EOF >> "$output_file"
  # Configuration will be populated from stack context
  # Component: $component
  # Stack: $stack
  
metadata:
  generator: manifest-generator.sh
  timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
  component_path: components/terraform/$component
EOF
        echo -e "${YELLOW}⚠️  Basic manifest generated (detailed config unavailable): ${output_file}${NC}"
    fi
}

generate_stack_template() {
    local stack_name="$1"
    local tenant="${2:-new-tenant}"
    local account="${3:-dev}"
    local environment="${4:-testenv-01}"
    local region="${5:-eu-west-2}"
    
    local output_dir="stacks/orgs/${tenant}/${account}/${region}/${environment}"
    
    echo -e "${CYAN}🏗️  Generating stack template: ${stack_name}${NC}"
    echo -e "${BLUE}📂 Output directory: ${output_dir}${NC}"
    
    mkdir -p "$output_dir"
    
    # Generate main stack file
    cat << EOF > "$output_dir/main.yaml"
# Stack Configuration: $stack_name
# Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
# Tenant: $tenant | Account: $account | Environment: $environment | Region: $region

terraform:
  vars:
    # Global variables for this stack
    tenant: $tenant
    account: $account
    environment: $environment
    region: $region
    
    # Stack-specific variables
    stack_name: "$stack_name"
    
import:
  # Import base configurations
  - catalog/vpc/defaults
  - mixins/tenant/$tenant
  - mixins/stage/$account
  - mixins/region/$region

components:
  terraform:
    # Core infrastructure components
    vpc:
      metadata:
        component: vpc
        inherits:
          - vpc/defaults
      vars:
        # VPC-specific configuration
        name: "\${var.tenant}-\${var.environment}-vpc"
        cidr_block: "10.0.0.0/16"
        
    # Add more components as needed
    # security-groups:
    #   metadata:
    #     component: securitygroup
    #   vars:
    #     name: "\${var.tenant}-\${var.environment}-sg"
EOF

    # Generate README for the stack
    cat << EOF > "$output_dir/README.md"
# Stack: $stack_name

Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')

## Configuration

- **Tenant:** $tenant
- **Account:** $account  
- **Environment:** $environment
- **Region:** $region

## Components

- VPC: Core networking infrastructure
- Add additional components as needed

## Usage

\`\`\`bash
# Validate the stack
gaia workflow validate --tenant $tenant --account $account --environment $environment

# Plan changes
gaia workflow plan-environment --tenant $tenant --account $account --environment $environment

# Apply changes (with confirmation)
gaia workflow apply-environment --tenant $tenant --account $account --environment $environment
\`\`\`

## Customization

Modify \`main.yaml\` to add or configure components for your infrastructure needs.
EOF

    echo -e "${GREEN}✅ Stack template generated: ${output_dir}${NC}"
    echo -e "${BLUE}📁 Files created:${NC}"
    echo -e "  - ${output_dir}/main.yaml"
    echo -e "  - ${output_dir}/README.md"
}

generate_component_template() {
    local component_name="$1"
    local output_dir="components/terraform/${component_name}"
    
    echo -e "${CYAN}🧩 Generating component template: ${component_name}${NC}"
    
    mkdir -p "$output_dir"
    
    # Generate main.tf
    cat << EOF > "$output_dir/main.tf"
# Terraform Component: $component_name
# Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

locals {
  name_prefix = "\${var.tenant}-\${var.environment}"
  
  tags = merge(var.tags, {
    Component = "$component_name"
    ManagedBy = "atmos"
  })
}

# Main resource configuration
# Replace with actual resource definitions
resource "null_resource" "${component_name}_placeholder" {
  triggers = {
    name_prefix = local.name_prefix
    component   = "$component_name"
  }
  
  provisioner "local-exec" {
    command = "echo 'Component $component_name initialized with name prefix: \${local.name_prefix}'"
  }
  
  tags = local.tags
}
EOF

    # Generate variables.tf
    cat << EOF > "$output_dir/variables.tf"
# Variables for $component_name component

variable "tenant" {
  type        = string
  description = "Tenant name"
  
  validation {
    condition     = can(regex("^[a-z0-9-]+$", var.tenant))
    error_message = "Tenant must contain only lowercase letters, numbers, and hyphens."
  }
}

variable "environment" {
  type        = string
  description = "Environment name"
  
  validation {
    condition     = can(regex("^[a-z0-9-]+$", var.environment))
    error_message = "Environment must contain only lowercase letters, numbers, and hyphens."
  }
}

variable "region" {
  type        = string
  description = "AWS region"
  default     = "eu-west-2"
  
  validation {
    condition     = can(regex("^[a-z0-9-]+$", var.region))
    error_message = "Region must be a valid AWS region."
  }
}

variable "tags" {
  type        = map(string)
  description = "Common tags to apply to all resources"
  default     = {}
}

# Component-specific variables
variable "enabled" {
  type        = bool
  description = "Whether to create the $component_name resources"
  default     = true
}

variable "name" {
  type        = string
  description = "Name for the $component_name resources"
  default     = null
}
EOF

    # Generate outputs.tf
    cat << EOF > "$output_dir/outputs.tf"
# Outputs for $component_name component

output "name_prefix" {
  description = "The name prefix used for resources"
  value       = local.name_prefix
}

output "tags" {
  description = "Tags applied to resources"
  value       = local.tags
  sensitive   = false
}

output "component_name" {
  description = "Name of the component"
  value       = "$component_name"
}

# Add component-specific outputs here
# Example:
# output "${component_name}_id" {
#   description = "ID of the main resource"
#   value       = resource.example.id
# }
EOF

    # Generate provider.tf
    cat << EOF > "$output_dir/provider.tf"
terraform {
  required_version = ">= 1.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Provider configuration is handled by Atmos
# No explicit provider block needed
EOF

    # Generate README.md
    cat << EOF > "$output_dir/README.md"
# $component_name Component

Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')

## Description

This is a Terraform component for managing $component_name resources.

## Usage

Add this component to your Atmos stack configuration:

\`\`\`yaml
components:
  terraform:
    $component_name:
      metadata:
        component: $component_name
      vars:
        enabled: true
        name: "my-${component_name}"
\`\`\`

## Variables

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|----------|
| tenant | Tenant name | string | n/a | yes |
| environment | Environment name | string | n/a | yes |
| region | AWS region | string | "eu-west-2" | no |
| enabled | Whether to create resources | bool | true | no |
| name | Resource name | string | null | no |
| tags | Common tags | map(string) | {} | no |

## Outputs

| Name | Description |
|------|-------------|
| name_prefix | The name prefix used for resources |
| tags | Tags applied to resources |
| component_name | Name of the component |

## Development

\`\`\`bash
# Validate the component
gaia terraform validate $component_name --stack fnx-dev-testenv-01

# Plan the component
gaia terraform plan $component_name --stack fnx-dev-testenv-01

# Get component info
make component-info COMPONENT=$component_name
\`\`\`
EOF

    echo -e "${GREEN}✅ Component template generated: ${output_dir}${NC}"
    echo -e "${BLUE}📁 Files created:${NC}"
    echo -e "  - ${output_dir}/main.tf"
    echo -e "  - ${output_dir}/variables.tf"
    echo -e "  - ${output_dir}/outputs.tf"
    echo -e "  - ${output_dir}/provider.tf"
    echo -e "  - ${output_dir}/README.md"
}

generate_resource_template() {
    local resource_type="$1"
    local output_file="${2:-templates/resources/${resource_type}.tf.template}"
    
    echo -e "${CYAN}🔧 Generating resource template: ${resource_type}${NC}"
    
    mkdir -p "$(dirname "$output_file")"
    
    case "$resource_type" in
        "aws_s3_bucket")
            cat << 'EOF' > "$output_file"
# S3 Bucket Resource Template

resource "aws_s3_bucket" "this" {
  bucket = "${local.name_prefix}-${var.bucket_suffix}"
  tags   = local.tags
}

resource "aws_s3_bucket_versioning" "this" {
  bucket = aws_s3_bucket.this.id
  versioning_configuration {
    status = var.versioning_enabled ? "Enabled" : "Suspended"
  }
}

resource "aws_s3_bucket_encryption" "this" {
  bucket = aws_s3_bucket.this.id
  
  server_side_encryption_configuration {
    rule {
      apply_server_side_encryption_by_default {
        sse_algorithm = "AES256"
      }
    }
  }
}

variable "bucket_suffix" {
  type        = string
  description = "Suffix for the S3 bucket name"
}

variable "versioning_enabled" {
  type        = bool
  description = "Enable S3 bucket versioning"
  default     = true
}

output "bucket_name" {
  description = "Name of the S3 bucket"
  value       = aws_s3_bucket.this.id
}

output "bucket_arn" {
  description = "ARN of the S3 bucket"
  value       = aws_s3_bucket.this.arn
}
EOF
            ;;
        "aws_vpc")
            cat << 'EOF' > "$output_file"
# VPC Resource Template

resource "aws_vpc" "this" {
  cidr_block           = var.cidr_block
  enable_dns_hostnames = var.enable_dns_hostnames
  enable_dns_support   = var.enable_dns_support
  
  tags = merge(local.tags, {
    Name = "${local.name_prefix}-vpc"
  })
}

resource "aws_internet_gateway" "this" {
  count  = var.create_internet_gateway ? 1 : 0
  vpc_id = aws_vpc.this.id
  
  tags = merge(local.tags, {
    Name = "${local.name_prefix}-igw"
  })
}

variable "cidr_block" {
  type        = string
  description = "CIDR block for the VPC"
  default     = "10.0.0.0/16"
}

variable "enable_dns_hostnames" {
  type        = bool
  description = "Enable DNS hostnames in the VPC"
  default     = true
}

variable "enable_dns_support" {
  type        = bool
  description = "Enable DNS support in the VPC"
  default     = true
}

variable "create_internet_gateway" {
  type        = bool
  description = "Create an internet gateway"
  default     = true
}

output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.this.id
}

output "vpc_cidr_block" {
  description = "CIDR block of the VPC"
  value       = aws_vpc.this.cidr_block
}

output "internet_gateway_id" {
  description = "ID of the internet gateway"
  value       = var.create_internet_gateway ? aws_internet_gateway.this[0].id : null
}
EOF
            ;;
        *)
            cat << EOF > "$output_file"
# Generic Resource Template: $resource_type
# Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

resource "$resource_type" "this" {
  # Add resource configuration here
  # Refer to Terraform documentation for $resource_type
  
  tags = local.tags
}

# Add variables specific to $resource_type
variable "${resource_type}_name" {
  type        = string
  description = "Name for the $resource_type resource"
  default     = null
}

# Add outputs specific to $resource_type
output "${resource_type}_id" {
  description = "ID of the $resource_type resource"
  value       = ${resource_type}.this.id
}
EOF
            ;;
    esac
    
    echo -e "${GREEN}✅ Resource template generated: ${output_file}${NC}"
}

list_templates() {
    echo -e "${CYAN}📋 Available Templates${NC}"
    echo -e "${YELLOW}────────────────────────────────────────────────────────${NC}"
    echo ""
    
    echo -e "${WHITE}Stack Templates:${NC}"
    echo -e "  ${GREEN}minimal-stack${NC}      - Basic VPC + Security Groups"
    echo -e "  ${GREEN}full-stack${NC}         - Complete production infrastructure" 
    echo -e "  ${GREEN}microservices${NC}      - Container-optimized with EKS + addons"
    echo -e "  ${GREEN}serverless${NC}         - Lambda + API Gateway + DynamoDB"
    echo ""
    
    echo -e "${WHITE}Component Templates:${NC}"
    echo -e "  ${GREEN}web-service${NC}        - ECS Fargate service with ALB"
    echo -e "  ${GREEN}api-service${NC}        - REST API with auto-scaling"
    echo -e "  ${GREEN}worker-service${NC}     - Background processing service"
    echo -e "  ${GREEN}cache-layer${NC}        - Redis/ElastiCache cluster"
    echo ""
    
    echo -e "${WHITE}Workflow Templates:${NC}"
    echo -e "  ${GREEN}deployment-pipeline${NC} - Complete CI/CD pipeline"
    echo -e "  ${GREEN}disaster-recovery${NC}   - Backup and restore workflows"
    echo -e "  ${GREEN}security-scan${NC}       - Security validation workflow"
    echo ""
    
    echo -e "${WHITE}Configuration Templates:${NC}"
    echo -e "  ${GREEN}production${NC}          - Security-hardened, HA configuration"
    echo -e "  ${GREEN}development${NC}         - Cost-optimized, developer-friendly"
    echo -e "  ${GREEN}staging${NC}             - Pre-production testing environment"
    echo ""
    
    echo -e "${WHITE}Resource Templates:${NC}"
    echo -e "  ${BLUE}s3-bucket-secure${NC}        - Production S3 bucket with encryption"
    echo -e "  ${BLUE}lambda-function${NC}         - Lambda with monitoring & permissions"
    echo -e "  ${BLUE}rds-cluster${NC}             - Aurora cluster with HA"
    echo -e "  ${BLUE}eks-cluster${NC}             - EKS cluster with best practices"
    echo ""
    
    echo -e "${WHITE}Quick Examples:${NC}"
    echo -e "  ${GREEN}# Create production environment${NC}"
    echo -e "  ${GREEN}./scripts/manifest-generator.sh template stack prod-env myorg prod production${NC}"
    echo -e ""
    echo -e "  ${GREEN}# Generate web service component${NC}"  
    echo -e "  ${GREEN}./scripts/manifest-generator.sh template component api-gateway${NC}"
    echo -e ""
    echo -e "  ${GREEN}# Copy configuration template${NC}"
    echo -e "  ${GREEN}cp templates/configs/production.yaml stacks/orgs/myorg/prod/config.yaml${NC}"
    echo -e ""
    echo -e "  ${GREEN}# Use workflow template${NC}"
    echo -e "  ${GREEN}cp templates/workflows/deployment-pipeline.yaml workflows/deploy.yaml${NC}"
}

main() {
    case "${1:-help}" in
        "stack")
            if [[ $# -lt 2 ]]; then
                echo -e "${RED}❌ Stack name required${NC}"
                print_usage
                exit 1
            fi
            generate_stack_manifest "$2" "${3:-}"
            ;;
        "component")
            if [[ $# -lt 2 ]]; then
                echo -e "${RED}❌ Component name required${NC}"
                print_usage
                exit 1
            fi
            generate_component_manifest "$2" "${3:-}" "${4:-}"
            ;;
        "template")
            if [[ $# -lt 3 ]]; then
                echo -e "${RED}❌ Template type and name required${NC}"
                print_usage
                exit 1
            fi
            case "$2" in
                "stack")
                    generate_stack_template "$3" "${4:-}" "${5:-}" "${6:-}" "${7:-}"
                    ;;
                "component")
                    generate_component_template "$3"
                    ;;
                *)
                    echo -e "${RED}❌ Unknown template type: $2${NC}"
                    echo -e "${YELLOW}Available types: stack, component${NC}"
                    exit 1
                    ;;
            esac
            ;;
        "resource")
            if [[ $# -lt 2 ]]; then
                echo -e "${RED}❌ Resource type required${NC}"
                print_usage
                exit 1
            fi
            generate_resource_template "$2" "${3:-}"
            ;;
        "list")
            list_templates
            ;;
        "help"|*)
            print_usage
            ;;
    esac
}

main "$@"